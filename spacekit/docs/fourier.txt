
```python
# a : (N,) array_like
#     First one-dimensional input array.
# v : (M,) array_like
#     Second one-dimensional input array.
# mode : {'full', 'valid', 'same'}, optional
#     'full':
#       By default, mode is 'full'.  This returns the convolution
#       at each point of overlap, with an output shape of (N+M-1,). At
#       the end-points of the convolution, the signals do not overlap
#       completely, and boundary effects may be seen.

#     'same':
#       Mode 'same' returns output of length ``max(M, N)``.  Boundary
#       effects are still visible.

#     'valid':
#       Mode 'valid' returns output of length
#       ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
#       for points where the signals overlap completely.  Values outside
#       the signal boundary have no effect.





# --------
# scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
#                            Transform.
# scipy.linalg.toeplitz : Used to construct the convolution operator.
# polymul : Polynomial multiplication. Same output as convolve, but also
#           accepts poly1d objects as input.

# Notes
# -----
# The discrete convolution operation is defined as

# .. math:: (a * v)[n] = \sum_{m = -\infty}^{\infty} a[m] v[n - m]

# It can be shown that a convolution :math:`x(t) * y(t)` in time/space
# is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
# domain, after appropriate padding (padding is necessary to prevent
# circular convolution).  Since multiplication is more efficient (faster)
# than convolution, the function `scipy.signal.fftconvolve` exploits the
# FFT to calculate the convolution of large data-sets.

# References
# ----------
# .. [1] Wikipedia, "Convolution",
#     https://en.wikipedia.org/wiki/Convolution

# Examples
# --------
# Note how the convolution operator flips the second array
# before "sliding" the two across one another:

# >>> np.convolve([1, 2, 3], [0, 1, 0.5])
# array([0. , 1. , 2.5, 4. , 1.5])

# Only return the middle values of the convolution.
# Contains boundary effects, where zeros are taken
# into account:

# >>> np.convolve([1,2,3],[0,1,0.5], 'same')
# array([1. ,  2.5,  4. ])

# The two arrays are of the same length, so there
# is only one position where they completely overlap:

# >>> np.convolve([1,2,3],[0,1,0.5], 'valid')
# array([2.5])



# # plot arrays
# rolling = x_train[0][:,1]
# plt.plot(x_train[0][:,0])
# plt.plot(rolling)

T = np.array([200,400,600,800])
s = x_train[0][:,1]
a0 = s[0:400]
a1 = s[200:600]
a2 = s[400:800]
a3 = s[600:1000]

A=np.array([a0,a1,a2,a3])
print(A.shape)

plt.specgram(A.flatten(),Fs=2,NFFT=256,noverlap=125);

plt.colorbar()


A_ = 1/A
plt.specgram(A_.flatten(),Fs=2,NFFT=256,noverlap=125);
plt.colorbar()
# a4 = s[T[0]:T[3]]
# a5 = s[T[1]:T[3]]
# a6 =s[T[2]:T[3]]
# a7 = np.sum([a1,a2,a3,a4,a5,a6,a7])/7
# plt.specgram(a4,Fs=2,NFFT=256,noverlap=125);
# plt.colorbar()
# a6.shape

# # Convolve two arrays using the Fast Fourier Transform.
import scipy.signal as sg
f1 = sg.fftconvolve(a0,a1)
f2 = sg.fftconvolve(a1,a2)
f3 = sg.fftconvolve(a2,a3)

F = np.array([f1,f2,f3])
F.shape


# plt.specgram(A.flatten(),Fs=2,NFFT=256,noverlap=25);
# plt.specgram(A.flatten(),Fs=2,NFFT=256,noverlap=50);
# plt.specgram(A.flatten(),Fs=2,NFFT=256,noverlap=100);


s1=x_train[0][:,1]
#T = dict(t1=200,t2 = 400,t3 = 600,t4 = 800)

# #harmonics
# H = np.array([8,16,32,64, 128,256,512,1024])
# H_neg = H*-1

# def harmonics(signal=s1,time_dict=T,):

#     #harmonics
#     H = np.array([8,16,32,64,128,256,512,1024])
#     H_neg = H*-1
    
#     S = []
#     V = []
    
#     for s in signal:
#         for t in time_dict:
#             N = s[t]
#             M
#             S.append(1 / np.max(s[:t]) - np.min(s[:t]))
            
        


    
    #plt.plot(s1[:f])
# for fprime in neg_harmonic:
#     plt.plot(s1[:fprime])
```