<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>training-RBM-guide</title><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s2 { color: black; font-family:"Courier New", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s3 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s4 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h2 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 h1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 h4 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 h3 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .p, p { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; margin:0pt; }
 .s5 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -1pt; }
 .s6 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s7 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; vertical-align: 4pt; }
 .s8 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s9 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s10 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s11 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s12 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s13 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s14 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -4pt; }
 .s15 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 .s16 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -4pt; }
 .s18 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 11pt; }
 .s19 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 11pt; }
 .s21 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -7pt; }
 .s22 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 2pt; }
 .s23 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -3pt; }
 .s24 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -1pt; }
 .s25 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -3pt; }
 .s26 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 4pt; }
 .s27 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; vertical-align: 5pt; }
 .s28 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; vertical-align: 1pt; }
 .s30 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6pt; }
 .s31 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 4pt; }
 .s32 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 11pt; vertical-align: 7pt; }
 .s33 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 3pt; }
 .s34 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -11pt; }
 .s35 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 3pt; }
 .s36 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 3pt; }
 .s37 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s38 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -3pt; }
 .s39 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -4pt; }
 .s40 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: 10pt; }
 .s41 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 8pt; vertical-align: 5pt; }
 .s42 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 4pt; }
 .s43 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -6pt; }
 .s44 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: 3pt; }
 .s45 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 1pt; }
 .s46 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 1pt; }
 .s47 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -1pt; }
 .s48 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 2pt; }
 .s49 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: 3pt; }
 .s50 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: -10pt; }
 .s51 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: 5pt; }
 .s53 { color: black; font-family:Menlo, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: 10pt; }
 .s54 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: 10pt; }
 .s55 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6pt; vertical-align: 3pt; }
 .s56 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: 15pt; }
 .s57 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 11pt; vertical-align: 15pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 1; }
 #l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l2 {padding-left: 0pt;counter-reset: c2 1; }
 #l2> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l3 {padding-left: 0pt;counter-reset: c2 1; }
 #l3> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l3> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l4 {padding-left: 0pt;counter-reset: c2 1; }
 #l4> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l4> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l5 {padding-left: 0pt;counter-reset: c2 1; }
 #l5> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l5> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l6 {padding-left: 0pt;counter-reset: c2 1; }
 #l6> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l6> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l7 {padding-left: 0pt;counter-reset: c2 1; }
 #l7> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l7> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l8 {padding-left: 0pt;counter-reset: c2 1; }
 #l8> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l8> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l9 {padding-left: 0pt;counter-reset: c2 1; }
 #l9> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l10 {padding-left: 0pt;counter-reset: c2 1; }
 #l10> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l10> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l11 {padding-left: 0pt;counter-reset: c2 1; }
 #l11> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l11> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l12 {padding-left: 0pt;counter-reset: c2 1; }
 #l12> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l12> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l13 {padding-left: 0pt;counter-reset: c2 1; }
 #l13> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l13> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 li {display: block; }
 #l14 {padding-left: 0pt;counter-reset: d1 1; }
 #l14> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 #l14> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l15 {padding-left: 0pt;counter-reset: d2 1; }
 #l15> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l15> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l16 {padding-left: 0pt;counter-reset: d2 1; }
 #l16> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l16> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l17 {padding-left: 0pt;counter-reset: d2 1; }
 #l17> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l17> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l18 {padding-left: 0pt;counter-reset: d2 1; }
 #l18> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l18> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l19 {padding-left: 0pt;counter-reset: d2 1; }
 #l19> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l19> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l20 {padding-left: 0pt;counter-reset: d2 1; }
 #l20> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l20> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l21 {padding-left: 0pt;counter-reset: d2 1; }
 #l21> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l21> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l22 {padding-left: 0pt;counter-reset: d2 1; }
 #l22> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l22> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l23 {padding-left: 0pt;counter-reset: d2 1; }
 #l23> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l23> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l24 {padding-left: 0pt;counter-reset: d2 1; }
 #l24> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l24> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l25 {padding-left: 0pt;counter-reset: d2 1; }
 #l25> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l25> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l26 {padding-left: 0pt;counter-reset: d2 1; }
 #l26> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l26> li:first-child>*:first-child:before {counter-increment: d2 0;  }
</style></head><body><p class="s1" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Department of Computer Science 6 King’s College Rd, Toronto University of Toronto M5S 3G4, Canada</p><p class="s2" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">http://learning.cs.toronto.edu <span class="s1">fax: +1 416 978 1455</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="638" height="1" alt="image" src="training-RBM-guide/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s3" style="padding-top: 5pt;text-indent: 0pt;text-align: right;">Copyright <span class="s4">Q</span>c</p><p class="s3" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">Geoffrey Hinton 2010.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 2pt;padding-left: 136pt;text-indent: 0pt;text-align: center;">August 2, 2010</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="492" height="4" alt="image" src="training-RBM-guide/Image_002.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 2pt;padding-left: 136pt;text-indent: 0pt;text-align: center;">UTML TR 2010–003</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-left: 136pt;text-indent: 0pt;line-height: 111%;text-align: center;">A Practical Guide to Training  Restricted Boltzmann Machines</h1><h4 style="padding-top: 3pt;padding-left: 136pt;text-indent: 0pt;text-align: center;">Version 1</h4><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 136pt;text-indent: 0pt;text-align: center;">Geoffrey Hinton</h3><p style="padding-left: 83pt;text-indent: 0pt;text-align: center;">Department of Computer Science, University of  Toronto</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="489" height="4" alt="image" src="training-RBM-guide/Image_003.png"/></span></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="641" height="2" alt="image" src="training-RBM-guide/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 2pt;padding-left: 83pt;text-indent: 0pt;line-height: 111%;text-align: center;">A Practical Guide to Training  Restricted Boltzmann Machines</h1><h4 style="padding-top: 3pt;padding-left: 136pt;text-indent: 0pt;text-align: center;">Version 1</h4><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="641" height="2" alt="image" src="training-RBM-guide/Image_005.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 2pt;padding-left: 136pt;text-indent: 0pt;text-align: center;">Geoffrey Hinton</h2><p class="s1" style="padding-left: 83pt;text-indent: 0pt;text-align: center;">Department of Computer Science, University of  Toronto</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Contents</h1><ol id="l1"><li><h3 style="padding-top: 18pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Introduction 3</h3></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">An overview of Restricted Boltzmann Machines and Contrastive Divergence 3</h3></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">How to collect statistics when using Contrastive Divergence 5</h3><ol id="l2"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Updating the hidden states 5</p></li><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Updating the visible states 6</p></li><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Collecting the statistics needed for learning 6</p></li><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for getting the learning signal for CD1<span class="s5"> </span>6</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">The size of a mini-batch 6</h3><ol id="l3"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for dividing the training set into mini-batches 7</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Monitoring the progress of learning 7</h3><ol id="l4"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for using the reconstruction error 7</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Monitoring the overfitting 8</h3><ol id="l5"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for monitoring the overfitting 8</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">The learning rate 8</h3><ol id="l6"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for setting the learning rates for weights and biases 8</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">The initial values of the weights and biases 9</h3><ol id="l7"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for setting the initial values of the weights and biases 9</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Momentum 9</h3><ol id="l8"><li><p style="padding-top: 4pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for using momentum 10</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Weight-decay 10</h3><ol id="l9"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for using weight-decay 11</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Encouraging sparse hidden activities 11</h3><ol id="l10"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for sparsity 12</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">The number of hidden units 12</h3><ol id="l11"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">A recipe for choosing the number of hidden units 12</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Different types of unit 13</h3><ol id="l12"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Softmax and multinomial units 13</p></li><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Gaussian visible units 13</p></li><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Gaussian visible and hidden units 14</p></li><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Binomial units 14</p></li><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Rectified linear units 14</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Varieties of contrastive divergence 15</h3></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Displaying what is happening during learning 16</h3></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Using RBM’s for discrimination 16</h3><ol id="l13"><li><p style="padding-top: 8pt;padding-left: 46pt;text-indent: -25pt;text-align: left;">Computing the free energy of a visible vector 17</p></li></ol></li><li><h3 style="padding-top: 19pt;padding-left: 21pt;text-indent: -16pt;text-align: left;">Dealing with missing values 17</h3></li></ol><p class="s6" style="padding-top: 6pt;padding-left: 22pt;text-indent: 0pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="255" height="1" alt="image" src="training-RBM-guide/Image_006.png"/></span></p><p class="s7" style="padding-left: 17pt;text-indent: 0pt;text-align: left;">1<span class="s8">If you make use of this technical report to train an RBM, please cite it in any resulting publication.</span></p><ol id="l14"><li><h1 style="padding-top: 1pt;padding-left: 29pt;text-indent: -24pt;text-align: left;">Introduction</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Restricted Boltzmann machines (RBMs) have been used as generative models of many different types of data including labeled or unlabeled images (Hinton et al., 2006a), windows of mel-cepstral coefficients that represent speech (Mohamed et al., 2009), bags of words that represent documents (Salakhutdinov and Hinton, 2009), and user ratings of movies (Salakhutdinov et al., 2007). In their conditional form they can be used to model high-dimensional temporal sequences such as video or motion capture data (Taylor et al., 2006) or speech (Mohamed and Hinton, 2010). Their most important use is as learning modules that are composed to form deep belief nets (Hinton et al., 2006a).</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">RBMs are usually trained using the contrastive divergence learning procedure (Hinton, 2002). This requires a certain amount of practical experience to decide how to set the values of numerical meta-parameters such as the learning rate, the momentum, the weight-cost, the sparsity target, the initial values of the weights, the number of hidden units and the size of each mini-batch. There are also decisions to be made about what types of units to use, whether to update their states stochastically or deterministically, how many times to update the states of the hidden units for each training case, and whether to start each sequence of state updates at a data-vector. In addition, it is useful to know how to monitor the progress of learning and when to terminate the training.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">For any particular application, the code that was used gives a complete specification of all of these decisions, but it does not explain why the decisions were made or how minor changes will affect performance. More significantly, it does not provide a novice user with any guidance about how to make good decisions for a new application. This requires some sensible heuristics and the ability to relate failures of the learning to the decisions that caused those failures.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">Over the last few years, the machine learning group at the University of Toronto has acquired considerable expertise at training RBMs and this guide is an attempt to share this expertise with other machine learning researchers. We are still on a fairly steep part of the learning curve, so the guide is a living document that will be updated from time to time and the version number should always be used when referring to it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-top: 10pt;padding-left: 29pt;text-indent: -24pt;line-height: 111%;text-align: left;">An overview of Restricted Boltzmann Machines and Contrastive Divergence</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Skip this section if you already know about RBMs</p><h3 style="padding-top: 8pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;"><span class="p">Consider a training set of binary vectors which we will assume are binary images for the purposes of explanation. The training set can be modeled using a two-layer network called a “Restricted Boltzmann Machine” (Smolensky, 1986; Freund and Haussler, 1992; Hinton, 2002) in which stochastic, binary pixels are connected to stochastic, binary feature detectors using symmetrically weighted connections. The pixels correspond to “visible” units of the RBM because their states are observed; the feature detectors correspond to “hidden” units. A joint configuration, (</span>v<i>, </i>h<span class="p">) of the visible and hidden units has an energy (Hopfield, 1982) given by:</span></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 5pt;padding-left: 120pt;text-indent: 0pt;text-align: left;">E<span class="p">(</span><b>v</b>, <b>h</b><span class="p">) = </span><span class="s11">−</span></p><p class="s12" style="padding-top: 3pt;text-indent: 0pt;text-align: right;">i<span class="s13">∈</span><span class="s6">visible</span></p><p class="s9" style="padding-top: 5pt;text-indent: 0pt;text-align: left;">aivi <span class="s11">−</span></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p class="s12" style="padding-top: 3pt;padding-left: 30pt;text-indent: 0pt;text-align: left;">j<span class="s13">∈</span><span class="s6">hidden</span></p><p class="s9" style="padding-top: 5pt;text-indent: 0pt;text-align: left;">bjhj <span class="s11">− </span>vihjwij <span class="p">(1)</span></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p class="s12" style="padding-top: 3pt;padding-left: 36pt;text-indent: 0pt;text-align: left;">i,j</p><p style="padding-top: 10pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">where <i>vi, hj </i>are the binary states of visible unit <i>i </i>and hidden unit <i>j</i>, <i>ai, bj </i>are their biases and <i>wij </i>is the weight between them. The network assigns a probability to every possible pair of a visible and a</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">hidden vector via this energy function:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 10pt;padding-left: 52pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"><span><img width="11" height="1" alt="image" src="training-RBM-guide/Image_007.png"/></span></p><p class="s9" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">p<span class="p">(</span><b>v</b>, <b>h</b><span class="p">) =</span></p><p class="s9" style="padding-left: 50pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Z</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 2pt;text-indent: 0pt;text-align: left;"><span class="s14">e</span><span class="s13">−</span>E<span class="s6">(</span><b>v</b>,<b>h</b><span class="s6">) </span><span class="s16">(2)</span></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">where the “partition function”, <i>Z</i>, is given by summing over all possible pairs of visible and hidden vectors:</p><p class="s12" style="padding-left: 204pt;text-indent: 0pt;line-height: 56%;text-align: left;"><span class="s14">Z </span><span class="p">= </span><span class="s9">e</span><span class="s13">−</span>E<span class="s6">(</span><b>v</b>,<b>h</b><span class="s6">) </span><span class="s16">(3)</span></p><p class="s15" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: center;">v<i>,</i>h</p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 14pt;text-align: left;">The probability that the network assigns to a visible vector, <b>v</b>, is given by summing over all possible hidden vectors:</p><p style="padding-left: 192pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><i>p</i>(<b>v</b>) = <u>1</u> <i>e</i><span class="s11">−</span><i>E</i>(<b>v</b><i>,</i><b>h</b>) (4)</p><p class="s9" style="text-indent: 0pt;line-height: 7pt;text-align: center;">Z</p><p class="s15" style="padding-left: 6pt;text-indent: 0pt;line-height: 8pt;text-align: center;">h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">The probability that the network assigns to a training image can be raised by adjusting the weights and biases to lower the energy of that image and to raise the energy of other images, especially those that have low energies and therefore make a big contribution to the partition function. The derivative of the log probability of a training vector with respect to a weight is surprisingly simple.</p><p class="s19" style="padding-top: 10pt;padding-left: 160pt;text-indent: 0pt;line-height: 30%;text-align: left;"><i>∂ </i>log <i>p</i>(<b>v</b>)<span class="p"> </span><span class="s21">= </span><span class="s11">(</span><i>v h </i><span class="s11">)</span></p><p class="s11" style="padding-top: 16pt;padding-left: 17pt;text-indent: 0pt;line-height: 6pt;text-align: left;">− (<span class="s9">v h </span>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;line-height: 6pt;text-align: right;">(5)</p><p class="s9" style="padding-top: 1pt;text-indent: 0pt;text-align: right;">∂wij</p><p class="s22" style="padding-left: 35pt;text-indent: 0pt;line-height: 10pt;text-align: left;">i j <span class="s12">data</span></p><p class="s22" style="padding-left: 21pt;text-indent: 0pt;line-height: 10pt;text-align: left;">i j <span class="s12">model</span></p><p style="padding-top: 10pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">where the angle brackets are used to denote expectations under the distribution specified by the subscript that follows. This leads to a very simple learning rule for performing stochastic steepest ascent in the log probability of the training data:</p><p class="s9" style="padding-top: 11pt;padding-left: 163pt;text-indent: 0pt;text-align: left;"><span class="p">∆</span>wij <span class="p">= </span>E<span class="p">(</span><span class="s11">(</span>vihj<span class="s11">)</span>data <span class="s11">− (</span>vihj<span class="s11">)</span>model<span class="p">)                                                     (6)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">where <i>E </i>is a learning rate.</p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">( )</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 14pt;text-align: justify;">Because there are no direct connections between hidden units in an RBM, it is very easy to get an unbiased sample of <i>vihj </i><span class="s23">data</span>. Given a randomly selected training image, <b>v</b>, the binary state, <i>hj</i>, of each hidden unit, <i>j</i>, is set to 1 with probability</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 166pt;text-indent: 0pt;text-align: left;"><i>p</i>(<i>hj </i>= 1 <span class="s11">| </span><b>v</b>) = <i>σ</i>(<i>bj </i>+ <i>viwij</i>) (7)</p><p class="s12" style="padding-top: 3pt;padding-left: 78pt;text-indent: 0pt;text-align: center;">i</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">where <i>σ</i>(<i>x</i>) is the logistic sigmoid function 1<i>/</i>(1 + exp(<span class="s11">−</span><i>x</i>)). <i>vihj </i>is then an unbiased sample.</p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">Because there are no direct connections between visible units in an RBM, it is also very easy to get an unbiased sample of the state of a visible unit, <i>given a hidden vector</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 166pt;text-indent: 0pt;text-align: left;"><i>p</i>(<i>vi </i>= 1 <span class="s11">| </span><b>h</b>) = <i>σ</i>(<i>ai </i>+ <i>hjwij</i>) (8)</p><p class="s12" style="padding-top: 3pt;padding-left: 74pt;text-indent: 0pt;text-align: center;">j</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">( )</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 16pt;line-height: 14pt;text-align: justify;">Getting an unbiased sample of <i>vihj </i><span class="s23">model</span>, however, is much more difficult. It can be done by starting at any random state of the visible units and performing alternating Gibbs sampling for a very long time. One iteration of alternating Gibbs sampling consists of updating all of the hidden units in parallel using equation 7 followed by updating all of the visible units in parallel using equation 8.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">A much faster learning procedure was proposed in Hinton (2002). This starts by setting the states of the visible units to a training vector. Then the binary states of the hidden units are all computed in parallel using equation 7. Once binary states have been chosen for the hidden units,</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">a “reconstruction” is produced by setting each <i>vi </i>to 1 with a probability given by equation 8.  The change in a weight is then given by</p><p class="s9" style="padding-top: 10pt;padding-left: 5pt;text-indent: 159pt;text-align: left;"><span class="p">∆</span>wij <span class="p">= </span>E<span class="p">(</span><span class="s11">(</span>vihj<span class="s11">)</span>data <span class="s11">− (</span>vihj<span class="s11">)</span>recon<span class="p">)                                                     (9)</span></p><p style="padding-top: 11pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">A simplified version of the same learning rule that uses the states of indivisdual units instead of pairwise products is used for the biases.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">The learning works well even though it is only crudely approximating the gradient of the log prob- ability of the training data (Hinton, 2002). The learning rule is much more closely approximating the gradient of another objective function called the Contrastive Divergence (Hinton, 2002) which is the difference between two Kullback-Liebler divergences, but it ignores one tricky term in this objective function so it is not even following that gradient. Indeed, Sutskever and Tieleman have shown that it is not following the gradient of any function (Sutskever and Tieleman, 2010). Nevertheless, it works well enough to achieve success in many significant applications.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">RBMs typically learn better models if more steps of alternating Gibbs sampling are used before collecting the statistics for the second term in the learning rule, which will be called the negative statistics. CD<i>n </i>will be used to denote learning using <i>n </i>full steps of alternating Gibbs sampling.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-top: 9pt;padding-left: 29pt;text-indent: -24pt;text-align: left;">How to collect statistics when using Contrastive Divergence</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">To begin with, we shall assume that all of the visible and hidden units are binary. Other types of units will be discussed in sections 13. We shall also assume that the purpose of the learning is to create a good generative model of the set of training vectors. When using RBMs to learn Deep Belief Nets (see the article on Deep Belief Networks at www.scholarpedia.org) that will subsequently be fine-tuned using backpropagation, the generative model is not the ultimate objective and it may be possible to save time by underfitting it, but we will ignore that here.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l15"><li><h2 style="padding-left: 35pt;text-indent: -30pt;text-align: left;">Updating the hidden states</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Assuming that the hidden units are binary and that you are using CD1, the hidden units should have stochastic binary states when they are being driven by a data-vector. The probability of turning on a hidden unit, <i>j</i>, is computed by applying the logistic function <i>σ</i>(<i>x</i>) = 1<i>/</i>(1 + exp( <i>x</i>)) to its “total input”:</p><p class="s9" style="padding-top: 1pt;padding-left: 175pt;text-indent: 0pt;text-align: left;">p<span class="p">(</span>hj <span class="p">= 1) = </span>σ<span class="p">(</span>bj <span class="p">+ </span>viwij<span class="p">) (10)</span></p><p class="s12" style="padding-top: 3pt;padding-left: 61pt;text-indent: 0pt;text-align: center;">i</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">and the hidden unit turns on if this probability is greater than a random number uniformly distributed between 0 and 1.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">It is very important to make these hidden states binary, rather than using the probabilities themselves. If the probabilities are used, each hidden unit can communicate a real-value to the visible units during the reconstruction. This seriously violates the information bottleneck created by the fact that a hidden unit can convey at most one bit (on average). This information bottleneck acts as a strong regularizer.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">For the last update of the hidden units, it is silly to use stochastic binary states because nothing depends on which state is chosen. So use the probability itself to avoid unnecessary sampling noise. When using CD<i>n</i>, only the final update of the hidden units should use the probability.</p></li><li><h2 style="padding-top: 2pt;padding-left: 35pt;text-indent: -30pt;text-align: left;">Updating the visible states</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Assuming that the visible units are binary, the correct way to update the visible states when generating a reconstruction is to stochastically pick a 1 or 0 with a probability determined by the total top-down input:</p><p class="s9" style="padding-top: 1pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">pi <span class="p">= </span>p<span class="p">(</span>vi <span class="p">= 1) = </span>σ<span class="p">(</span>ai <span class="p">+ </span>hjwij<span class="p">) (11)</span></p><p class="s12" style="padding-top: 3pt;padding-left: 80pt;text-indent: 0pt;text-align: center;">j</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">However, it is common to use the probability, <i>pi</i>, instead of sampling a binary value. This is not nearly as problematic as using probabilities for the data-driven hidden states and it reduces sampling noise thus allowing faster learning. There is some evidence that it leads to slightly worse density models (Tijmen Tieleman, personal communication, 2008). This probably does not matter when using an RBM to pretrain a layer of hidden features for use in a deep belief net.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h2 style="padding-left: 35pt;text-indent: -30pt;text-align: left;">Collecting the statistics needed for learning</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Assuming that the visible units are using real-valued probabilities instead of stochastic binary values, there are two sensible ways to collect the positive statistics for the connection between visible unit <i>i </i>and hidden unit <i>j</i>:</p><p class="s9" style="padding-left: 136pt;text-indent: 0pt;text-align: center;"><span class="s11">(</span>p<span class="s24">i</span>h<span class="s24">j</span><span class="s11">)</span><span class="s25">data</span><span class="s6">        </span><span class="p">or      </span><span class="s11">(</span>p<span class="s24">i</span>p<span class="s24">j</span><span class="s11">)</span><span class="s25">data</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">where <i>pj </i>is a probability and <i>hj </i>is a binary state that takes value 1 with probability <i>pj</i>. Using <i>hj </i>is closer to the mathematical model of an RBM, but using <i>pj </i>usually has less sampling noise which allows slightly faster learning<span class="s26">2</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h2 style="padding-top: 7pt;padding-left: 35pt;text-indent: -30pt;text-align: left;">A recipe for getting the learning signal for CD<span class="s1">1</span></h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">When the hidden units are being driven by data, <i>always </i>use stochastic binary states. When they are being driven by reconstructions, always use probabilities without sampling.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;text-align: justify;">Assuming the visible units use the logistic function, use real-valued probabilities for both the data and the reconstructions<span class="s26">3</span>.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">When collecting the pairwise statistics for learning weights or the individual statistics for learning biases, use the probabilities, not the binary states, and make sure the weights have random initial values to break symmetry.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 29pt;text-indent: -24pt;text-align: left;">The size of a mini-batch</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">It is possible to update the weights after estimating the gradient on a single training case, but it is often more efficient to divide the training set into small “mini-batches” of 10 to 100 cases<span class="s26">4</span>. This allows matrix-matrix multiplies to be used which is very advantageous on GPU boards or in Matlab.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="255" height="1" alt="image" src="training-RBM-guide/Image_008.png"/></span></p><p class="s8" style="padding-left: 5pt;text-indent: 12pt;text-align: justify;"><span class="s27">2</span><span class="s28">Usin</span>g  <i>h</i><span class="s30">j   </span><span class="s28">al</span>ways  creates  more  noise  in  the  positive  statistics  than  using  <i>p</i><span class="s30">j   </span><span class="s28">but</span>  it  can  actually  create  less  noise  in the  <i>difference  </i>of  the  positive  and  negative  statistics  because  the  negative  statistics  depend  on  the  binary  decision  for the  state  of  <i>j  </i>that  is  used  for  creating  the  reconstruction.  The  probability  of  <i>j  </i>when  driven  by  the  reconstruction  is highly correlated with the binary decision that was made for <i>j  </i>when it was driven by the data.</p><p class="s7" style="padding-left: 17pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">3<span class="s8">So there is nothing random about the generation of the reconstructions given the binary states of the hidden units.</span></p><p class="s7" style="padding-left: 5pt;text-indent: 12pt;line-height: 106%;text-align: justify;">4<span class="s8">The word “batch” is confusing and will be avoided because when it is used to contrast with “on-line” it usually means the entire training set.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">To avoid having to change the learning rate when the size of a mini-batch is changed, it is helpful to divide the total gradient computed on a mini-batch by the size of the mini-batch, so when talking about learning rates we will assume that they multiply the average, per-case gradient computed on a mini-batch, not the total gradient for the mini-batch.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;text-align: justify;">It is a serious mistake to make the mini-batches too large when using stochastic gradient descent. Increasing the mini-batch size by a factor of N leads to a more reliable gradient estimate but it does not increase the maximum stable learning rate by a factor of N, so the net effect is that the weight updates are smaller <i>per gradient evaluation</i><span class="s26">5</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l16"><li><h2 style="padding-left: 35pt;text-indent: -30pt;text-align: left;">A recipe for dividing the training set into mini-batches</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">For datasets that contain a small number of equiprobable classes, the ideal mini-batch size is often equal to the number of classes and each mini-batch should contain one example of each class to reduce the sampling error when estimating the gradient for the whole training set from a single mini-batch. For other datasets, first randomize the order of the training examples then use minibatches of size about 10.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 29pt;text-indent: -24pt;text-align: left;">Monitoring the progress of learning</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">It is easy to compute the squared error between the data and the reconstructions, so this quantity is often printed out during learning. The reconstruction error on the entire training set should fall rapidly and consistently at the start of learning and then more slowly. Due to the noise in the gradient estimates, the reconstruction error on the individual mini-batches will fluctuate gently after the initial rapid descent. It may also oscillate gently with a period of a few mini-batches when using high momentum (see section 9).</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">Although it is convenient, the reconstruction error is actually a very poor measure of the progress of learning. It is not the function that CD<i>n </i>learning is approximately optimizing, especially for <i>n &gt;&gt; </i>1, and it systematically confounds two different quantities that are changing during the learning. The first is the difference between the empirical distribution of the training data and the equilibrium distribution of the RBM. The second is the mixing rate of the alternating Gibbs Markov chain. If the mixing rate is very low, the reconstruction error will be very small even when the distributions of the data and the model are very different. As the weights increase the mixing rate falls, so decreases in reconstruction error do not necessarily mean that the model is improving and, conversely, small increases do not necessarily mean the model is getting worse. Large increases, however, are a bad sign except when they are temporary and caused by changes in the learning rate, momentum, weight-cost or sparsity meta-parameters.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l17"><li><h2 style="padding-left: 35pt;text-indent: -30pt;text-align: left;">A recipe for using the reconstruction error</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Use it but don’t trust it. If you really want to know what is going on during the learning, use multiple histograms and graphic displays as described in section 15. Also consider using Annealed Importance</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="255" height="1" alt="image" src="training-RBM-guide/Image_009.png"/></span></p><p class="s7" style="padding-left: 5pt;text-indent: 12pt;line-height: 106%;text-align: justify;">5<span class="s8">The easy way to parallelize the learning on a cluster is to divide each mini-batch into sub-mini-batches and to use different cores to compute the gradients on each sub-mini-batch. The gradients computed by different cores must then be combined. To minimize the ratio of communication to computation, it is tempting to make the sub-mini-batches large. This usually makes the learning much less efficient, thus wiping out much of the gain achieved by using multiple cores (Vinod Nair, personal communication, 2007).</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Sampling (Salakhutdinov and Murray, 2008) to estimate the density on held out data. If you are learning a joint density model of labelled data (see section 16), consider monitoring the discriminative performance on the training data and on a held out validation set.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 29pt;text-indent: -24pt;text-align: left;">Monitoring the overfitting</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 106%;text-align: justify;">When learning a generative model, the obvious quantity to monitor is the probability that the current model assigns to a datapoint. When this probability starts to decrease for held out validation data, it is time to stop learning. Unfortunately, for large RBMs, it is very difficult to compute this probability because it requires knowledge of the partition function. Nevertheless, it is possible to directly monitor the overfitting by comparing the free energies of training data and held out validation data. In this comparison, the partition function cancels out. The free energy of a data vector can be computed in a time that is linear in the number of hidden units (see section 16.1). If the model is not overfitting at all, the average free energy should be about the same on training and validation data. As the model starts to overfit the average free energy of the validation data will rise relative to the average free energy of the training data and this gap represents the amount of overfitting<span class="s26">6</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l18"><li><h2 style="padding-left: 35pt;text-indent: -30pt;text-align: left;">A recipe for monitoring the overfitting</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">After every few epochs, compute the average free energy of a representative subset of the training data and compare it with the average free energy of a validation set. Always use the same subset of the training data.  If the gap starts growing, the model is overfitting, though the probability of the training data may be growing even faster than the gap, so the probability of the validation data may still be improving. Make sure that the same weights are used when computing the two averages that you wish to compare.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 29pt;text-indent: -24pt;text-align: left;">The learning rate</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">If the learning rate is much too large, the reconstruction error usually increases dramatically and the weights may explode.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">If the learning rate is reduced while the network is learning normally, the reconstruction error will usually fall significiantly. This is not necessarily a good thing. It is due, in part, to the smaller noise level in the stochastic weight updates and it is generally accompanied by slower learning in the long term. Towards the end of learning, however, it typically pays to decrease the learning rate. Averaging the weights across several updates is an alternative way to remove some of the noise from the final weights.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l19"><li><h2 style="padding-left: 35pt;text-indent: -30pt;text-align: left;">A recipe for setting the learning rates for weights and biases</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">A good rule of thumb for setting the learning rate (Max Welling, personal communication, 2002) is to look at a histogram of the weight updates and a histogram of the weights. The updates should be about 10<span class="s31">−</span><span class="s6">3 </span>times the weights (to within about an order of magnitude). When a unit has a very</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="255" height="1" alt="image" src="training-RBM-guide/Image_010.png"/></span></p><p class="s8" style="padding-left: 5pt;text-indent: 12pt;line-height: 106%;text-align: justify;"><span class="s7">6</span>The average free energies often change by large amounts during learning and this means very little because the log partition function also changes by large amounts. It is only <i>differences </i>in free energies that are easy to interpret without knowing the partition function.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">large fan-in, the updates should be smaller since many small changes in the same direction can easily reverse the sign of the gradient. Conversely, for biases, the updates can be bigger.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 29pt;text-indent: -24pt;text-align: left;">The initial values of the weights and biases</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The weights are typically initialized to small random values chosen from a zero-mean Gaussian with a standard deviation of about 0<i>.</i>01. Using larger random values can speed the initial learning, but it may lead to a slightly worse final model. Care should be taken to ensure that the initial weight values do not allow typical visible vectors to drive the hidden unit probabilities very close to 1 or 0 as this significantly slows the learning. If the statistics used for learning are stochastic, the initial weights can all be zero since the noise in the statistics will make the hidden units become different from one another even if they all have identical connectivities.</p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">It is usually helpful to initialize the bias of visible unit <i>i </i>to log[<i>pi/</i>(1   <i>pi</i>)] where <i>pi </i>is the proportion of training vectors in which unit <i>i </i>is on.  If this is not done, the early stage of learning will use the hidden units to make <i>i </i>turn on with a probability of approximately <i>pi</i>.</p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">When using a sparsity target probability of <i>t </i>(see section 11), it makes sense to initialize the hidden biases to be log[<i>t/</i>(1  <i>t</i>)]. Otherwise, initial hidden biases of 0 are usually fine. It is also possible to start the hidden units with quite large negative biases of about 4 as a crude way of encouraging sparsity.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l20"><li><h2 style="padding-left: 35pt;text-indent: -30pt;text-align: left;">A recipe for setting the initial values of the weights and biases</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Use small random values for the weights chosen from a zero-mean Gaussian with a standard deviation of 0<i>.</i>01.  Set the hidden biases to 0.  Set the visible biases to log[<i>pi/</i>(1    <i>pi</i>)] where <i>pi </i>is the proportion of  training  vectors  in  which  unit  <i>i  </i>is  on.  Look  at  the  activities  of  the  hidden  units  occasionally  to check that they are not always on or off.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 29pt;text-indent: -24pt;text-align: left;">Momentum</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Momentum is a simple method for increasing the speed of learning when the objective function contains long, narrow and fairly straight ravines with a gentle but consistent gradient along the floor of the ravine and much steeper gradients up the sides of the ravine. The momentum method simulates a heavy ball rolling down a surface. The ball builds up velocity along the floor of the ravine, but not across the ravine because the opposing gradients on opposite sides of the ravine cancel each other out over time. Instead of using the estimated gradient times the learning rate to increment the <i>values </i>of the parameters, the momentum method uses this quantity to increment the <i>velocity</i>, <b>v</b>, of the parameters and the current velocity is then used as the parameter increment.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">The velocity of the ball is assumed to decay with time and the “momentum” meta-parmeter, <i>α </i>is the fraction of the previous velocity that remains after computing the gradient on a new mini-batch:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 157pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="p">∆</span>θ <span class="p">(</span>t<span class="p">) = </span>v <span class="p">(</span>t<span class="p">) = </span>αv <span class="p">(</span>t <span class="s11">− </span><span class="p">1) </span><span class="s11">− </span>E<u>dE</u> <span class="p">(</span>t<span class="p">) (12)</span></p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: right;">i i i</p><p class="s9" style="padding-top: 1pt;padding-left: 48pt;text-indent: 0pt;text-align: left;">dθi</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: left;">If the gradient remains constant, the terminal velocity will exceed <i>EdE/dθi </i>by a factor of 1<i>/</i>(1 <i>α</i>). This is a factor of 10 for a momentum of 0.9 which is a typical setting of this meta-parameter. The</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">temporal smoothing in the momentum method avoids the divergent oscillations across the ravine that would be caused by simply increasing the learning rate by a factor of 1<i>/</i>(1 <span class="s11">− </span><i>α</i>).</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">The momentum method causes the parameters to move in a direction that is not the direction of steepest descent, so it bears some resemblance to methods like conjugate gradient, but the way it uses the previous gradients is much simpler. Unlike methods that use different learning rates for each parameter, momentum works just as well when the ravines are not aligned with the parameter axes.</p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">An alternative way of viewing the momentum method (Tijmen Tieleman, personal communica- tion, 2008) is as follows: It is equivalent to increasing the learning rate by a factor of 1<i>/</i>(1 <i>α</i>) but delaying the full effect of each gradient estimate by dividing the full increment into a series of expo- nentially decaying installments. This gives the system time to respond to the early installments by moving to a region of parameter space that has opposing gradients before it feels the full effect of the increment. This, in turn, allows the learning rate to be larger without causing unstable oscillations.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">At the start of learning, the random initial parameter values may create very large gradients and the system is unlikely to be in the floor of a ravine, so it is usually best to start with a low momentum of 0.5 for a number of parameter updates. This very conservative momentum typically makes the learning more stable than no momentum at all by damping oscillations across ravines (Hinton, 1978).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l21"><li><h2 style="padding-left: 35pt;text-indent: -30pt;text-align: left;">A recipe for using momentum</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Start with a momentum of 0<i>.</i>5. Once the large initial progress in the reduction of the reconstruction error has settled down to gentle progress, increase the momentum to 0.9. This shock may cause a transient increase in the reconstruction error. If this causes a more lasting instability, keep reducing the learning rate by factors of 2 until the instability disappears.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 37pt;text-indent: -32pt;text-align: left;">Weight-decay</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Weight-decay works by adding an extra term to the normal gradient. The extra term is the derivative of a function that penalizes large weights. The simplest penalty function, called “L2”, is half of the sum of the squared weights times a coefficient which will be called the weight-cost.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">It is important to multiply the derivative of the penalty term by the learning rate. Otherwise, changes in the learning rate change the function that is being optimized rather than just changing the optimization procedure.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;text-align: justify;">There are four different reasons for using weight-decay in an RBM. The first is to improve general- ization to new data by reducing overfitting to the training data<span class="s26">7</span>. The second is to make the receptive fields of the hidden units smoother and more interpretable by shrinking useless weights. The third is to “unstick” hidden units that have developed very large weights early in the training and are either always firmly on or always firmly off. A better way to allow such units to become useful again is to use a “sparsity” target as described in section 11.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;text-align: justify;">The fourth reason is to improve the mixing rate of the alternating Gibbs Markov chain. With small weights, the Markov chain mixes more rapidly<span class="s26">8</span>. The CD learning procedure is based on ignoring</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="255" height="1" alt="image" src="training-RBM-guide/Image_011.png"/></span></p><p class="s7" style="padding-left: 5pt;text-indent: 12pt;line-height: 106%;text-align: justify;">7<span class="s8">Since the penalty is applied on every mini-batch, Bayesians really ought to divide the weight-cost by the size of the training set. They can then interpret weight-decay as the effect of a Gaussian weight prior whose variance is independent of the size of the training set. This division is typically not done. Instead, larger weight-costs are used for smaller training sets.</span></p><p class="s7" style="padding-left: 17pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">8<span class="s8">With all zero weights, it reaches its rather boring stationary distribution in a single full step.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">derivatives that come from later steps in the Markov chain (Hinton, Osindero and Teh, 2006), so it tends to approximate maximum likelihood learning better when the mixing is fast. The ignored derivatives are then small for the following reason: When a Markov chain is very close to its stationary distribution, the best parameters for modeling samples from the chain are very close to its current parameters.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">A different form of weight-decay called “L1” is to use the derivative of the sum of the absolute values of the weights. This often causes many of the weights to become exactly zero whilst allowing a few of the weights to grow quite large. This can make it easier to interpret the weights. When learning features for images, for example, L1 weight-decay often leads to strongly localized receptive fields.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">An alternative way to control the size of the weights is to impose a maximum allowed value on the sum of the squares or absolute values of the incoming weights for each unit. After each weight update, the weights are rescaled if they exceed this maximum value. This helps to avoid hidden units getting stuck with extremely small weights, but a sparsity target is probably a better way to avoid this problem.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l22"><li><h2 style="padding-left: 42pt;text-indent: -37pt;text-align: justify;">A recipe for using weight-decay</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">For an RBM, sensible values for the weight-cost coefficient for L2 weight-decay typically range from</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">0<i>.</i>01 to 0<i>.</i>00001. Weight-cost is typically not applied to the hidden and visible biases because there are far fewer of these so they are less likely to cause overfitting. Also, the biases sometimes need to be quite large.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">Try an initial weight-cost of 0<i>.</i>0001. If you are using Annealed Importance Sampling (Salakhut- dinov and Murray, 2008) to estimate the density on a held-out validation set, try adjusting the weight-cost by factors of 2 to optimize density. Small differences in weight-cost are unlikely to cause big differences in performance. If you are training a joint density model that allows you to test discriminative performance on a validation set this can be used in place of the density for optimizing the weight-cost. However, in either case, remember that weight-decay does more than just preventing overfitting. It also increases the mixing rate which makes CD learning a better approximation to maximum likelihood. So even if overfitting is not a problem because the supply of training data is infinite, weight-decay can still be helpful.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 37pt;text-indent: -32pt;text-align: justify;">Encouraging sparse hidden activities</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Hidden units that are only rarely active are typically easier to interpret than those that are active about half of the time. Also, discriminative performance is sometimes improved by using features that are only rarely active (Nair and Hinton, 2009).</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">Sparse activities of the binary hidden units can be achieved by specifying a “sparsity target” which is the desired probability of being active, <i>p &lt;&lt; </i>1. An additional penalty term is then used to encourage the actual probability of being active, <i>q</i>, to be close to <i>p</i>. <i>q </i>is estimated by using an exponentially decaying average of the mean probability that a unit is active in each mini-batch:</p><p class="s9" style="padding-top: 11pt;padding-left: 5pt;text-indent: 169pt;line-height: 191%;text-align: left;">qnew <span class="p">= </span>λqold <span class="p">+ (1 </span><span class="s11">− </span>λ<span class="p">)</span>qcurrent <span class="p">(13) where </span>qcurrent <span class="p">is the mean activation probability of the hidden unit on the current mini-batch.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: left;">The natural penalty measure to use is the cross entropy between the desired and actual distribu- tions:</p><p style="padding-left: 132pt;text-indent: 0pt;text-align: left;">Sparsity penalty <span class="s11">∝ −</span><i>p </i>log <i>q </i><span class="s11">− </span>(1 <span class="s11">− </span><i>p</i>) log(1 <span class="s11">− </span><i>q</i>) (14)</p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">For logistic units this has a simple derivative of <i>q p </i>with respect to the total input to a unit. This derivative, scaled by a meta-parameter called “sparsity-cost”, is used to adjust both the bias and the incoming weights of each hidden unit. It is important to apply the same derivative to both. If the derivative is only applied to the bias, for example, the bias will typically keep becoming more negative to ensure the hidden unit is rarely on, but the weights will keep becoming more positive to make the unit more useful.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l23"><li><h2 style="padding-left: 42pt;text-indent: -37pt;text-align: left;">A recipe for sparsity</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Set the sparsity target to between 0<i>.</i>01 and 0<i>.</i>1<span class="s26">9</span>. Set the decay-rate, <i>λ</i>, of the estimated value of <i>q </i>to be between 0<i>.</i>9 and 0<i>.</i>99. Histogram the mean activities of the hidden units and set the sparsity-cost so that the hidden units have mean probabilities in the vicinity of the target. If the probabilities are tightly clustered around the target value, reduce the sparsity-cost so that it interferes less with the main objective of the learning.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 37pt;text-indent: -32pt;text-align: left;">The number of hidden units</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Intuitions derived from discriminative machine learning are a bad guide for determining a sensible number of hidden units. In discriminative learning, the amount of constraint that a training case imposes on the parameters is equal to the number of bits that it takes to specify the label. Labels usually contain very few bits of information, so using more parameters than training cases will typ- ically cause severe overfitting. When learning generative models of high-dimensional data, however, it is the number of bits that it takes to specify a data vector that determines how much constraint each training case imposes on the parameters of the model. This can be several orders of magnitude greater than number of bits required to specify a label. So it may be quite reasonable to fit a million parameters to 10,000 training images if each image contains 1,000 pixels. This would allow 1000 glob- ally connected hidden units. If the hidden units are locally connected or if they use weight-sharing, many more can be used.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l24"><li><h2 style="padding-left: 42pt;text-indent: -37pt;text-align: left;">A recipe for choosing the number of hidden units</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Assuming that the main issue is overfitting rather than the amount of computation at training or test time, estimate how many bits it would take to describe each data-vector if you were using a good model (<i>i.e. </i>estimate the typical negative log2 probability of a datavector under a good model). Then multiply that estimate by the number of training cases and use a number of parameters that is about an order of magnitude smaller. If you are using a sparsity target that is very small, you may be able to use more hidden units. If the training cases are highly redundant, as they typically will be for very big training sets, you need to use fewer parameters.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="255" height="1" alt="image" src="training-RBM-guide/Image_012.png"/></span></p><p class="s8" style="padding-left: 5pt;text-indent: 12pt;line-height: 106%;text-align: left;"><span class="s7">9</span>If you are only using the sparsity target to revive hidden units that are never active and suppress hidden units that are always active, a target value of 0<i>.</i>5 makes sense (even though it makes nonsense of the name).</p></li></ol></li><li><h1 style="padding-top: 1pt;padding-left: 37pt;text-indent: -32pt;text-align: left;">Different types of unit</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">RBM’s were developed using binary visible and hidden units, but many other types of unit can also be used. A general treatment for units in the exponential family is given in (Welling et al., 2005). The main use of other types of unit is for dealing with data that is not well-modeled by binary (or logistic) visible units.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l25"><li><h2 style="padding-left: 42pt;text-indent: -37pt;text-align: left;">Softmax and multinomial units</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">For a binary unit, the probability of turning on is given by the logistic sigmoid function of its total input, <i>x</i>.</p><p class="s9" style="padding-top: 5pt;text-indent: 0pt;text-align: right;">p <span class="p">= </span>σ<span class="p">(</span>x<span class="p">) =</span></p><p style="padding-bottom: 2pt;padding-left: 2pt;text-indent: 0pt;line-height: 11pt;text-align: center;">1</p><p style="padding-left: 2pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="48" height="1" alt="image" src="training-RBM-guide/Image_013.png"/></span></p><p style="padding-left: 136pt;text-indent: 0pt;text-align: center;">1 + <i>e</i><span class="s33">−</span><span class="s12">x</span></p><p class="s34" style="padding-left: 2pt;text-indent: 0pt;line-height: 41%;text-align: left;">= <i>e</i><span class="s12">x</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="1" alt="image" src="training-RBM-guide/Image_014.png"/></span></p><p class="s9" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">e<span class="s35">x </span><span class="p">+ </span>e<span class="s36">0</span></p><p style="padding-top: 5pt;text-indent: 0pt;text-align: right;">(15)</p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The energy contributed by the unit is <i>x </i>if it is on and 0 if it is off. Equation 15 makes it clear that the probability of each of the two possible states is proportional to the negative exponential of its energy. This can be generalized to <i>K </i>alternative states.</p><p class="s14" style="padding-top: 5pt;padding-left: 136pt;text-indent: 0pt;line-height: 8pt;text-align: center;">e<span class="s12">x</span><span class="s37">j</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="55" height="1" alt="image" src="training-RBM-guide/Image_015.png"/></span></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="text-indent: 0pt;text-align: right;">pj <span class="p">=</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 13pt;text-indent: 0pt;line-height: 9pt;text-align: left;">K</p><p class="s12" style="padding-left: 13pt;text-indent: 0pt;line-height: 9pt;text-align: left;">i<span class="s6">=1</span></p><p class="s38" style="padding-top: 9pt;text-indent: 0pt;text-align: left;">e<span class="s12">x</span><span class="s37">i</span></p><p style="text-indent: 0pt;text-align: right;">(16)</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 4pt;line-height: 107%;text-align: justify;">This is often called a “softmax” unit. It is the appropriate way to deal with a quantity that has <i>K </i>alternative values which are not ordered in any way. A softmax can be viewed as a set of binary units whose states are mutually constrained so that exactly one of the <i>K </i>states has value 1 and the rest have value 0. When viewed in this way, the learning rule for the binary units in a softmax is identical to the rule for standard binary units. The only difference is in the way the probabilities of the states are computed and the samples are taken.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">A further generalization of the softmax unit is to sample <i>N </i>times (with replacement) from the probability distribution instead of just sampling once. The <i>K </i>different states can then have integer values bigger than 1, but the values must add to <i>N </i>. This is called a multinomial unit and, again, the learning rule is unchanged.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h2 style="padding-left: 42pt;text-indent: -37pt;text-align: left;">Gaussian visible units</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">For data such as patches of natural images or the Mel-Cepstrum coefficients used to represent speech, logistic units are a very poor representation. One solution is to replace the binary visible units by linear units with independent Gaussian noise. The energy function then becomes:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="text-indent: 0pt;text-align: right;">E<span class="p">(</span><b>v</b>, <b>h</b><span class="p">) =</span></p><p class="s9" style="padding-top: 7pt;padding-bottom: 1pt;padding-left: 136pt;text-indent: 0pt;text-align: center;"><span class="p">(</span>vi <span class="s11">− </span>ai<span class="p">)</span><span class="s26">2</span></p><p style="padding-left: 22pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="59" height="1" alt="image" src="training-RBM-guide/Image_016.png"/></span></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p class="s39" style="text-indent: 0pt;line-height: 82%;text-align: left;">2 <span class="s11">−</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 132pt;text-indent: 0pt;line-height: 5pt;text-align: center;">2<i>σ</i></p><p class="s9" style="padding-top: 15pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">bjhj <span class="s11">−</span></p><p class="s40" style="padding-top: 8pt;text-indent: 0pt;text-align: left;"> <span class="s10"> </span><span class="s32">v</span><span class="s41">i</span><span class="s12"> </span><span class="s9">h w </span><span class="p">(17)</span></p><p class="s12" style="text-indent: 0pt;text-align: right;">i<span class="s13">∈</span><span class="s6">vis </span><span class="s22">i</span></p><p class="s12" style="padding-top: 2pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">j<span class="s13">∈</span><span class="s6">hid</span></p><p class="s12" style="padding-left: 36pt;text-indent: 0pt;line-height: 12pt;text-align: left;">i,j <span class="s42">i</span></p><p class="s43" style="text-indent: 0pt;line-height: 58%;text-align: left;">σ <span class="s12">j ij</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">where <i>σi </i>is the standard deviation of the Gaussian noise for visible unit <i>i</i>.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">It is possible to learn the variance of the noise for each visible unit but this is difficult using CD1. In many applications, it is much easier to first normalise each component of the data to have zero mean and unit variance and then to use noise free reconstructions, with the variance in equation 17 set to 1. The reconstructed value of a Gaussian visible unit is then equal to its top-down input from the binary hidden units plus its bias.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">The learning rate needs to be about one or two orders of magnitude smaller than when using binary visible units and some of the failures reported in the literature are probably due to using a</p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">learning rate that is much too big. A smaller learning rate is required because there is no upper bound to the size of a component in the reconstruction and if one component becomes very large, the weights emanating from it will get a very big learning signal. With binary hidden and visible units, the learning signal for each training case must lie between 1 and 1, so binary-binary nets are much more stable.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h2 style="padding-left: 42pt;text-indent: -37pt;text-align: left;">Gaussian visible and hidden units</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="62" height="1" alt="image" src="training-RBM-guide/Image_017.png"/></span></p><p class="s9" style="text-indent: 0pt;text-align: left;">wij <span class="p">(18)</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">If both the visible and the hidden units are Gaussian, the instability problems become much worse. The individual activities are held close to their means by quadratic “containment” terms with coef- ficients determined by the standard deviations of the assumed noise levels:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="1" alt="image" src="training-RBM-guide/Image_018.png"/></span></p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="text-indent: 0pt;text-align: left;">E<span class="p">(</span><b>v</b>, <b>h</b><span class="p">) =</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">+</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 8pt;padding-bottom: 1pt;text-indent: 0pt;text-align: right;"><span class="s44"> </span><span class="s10"> </span><span class="p">(</span>vi <span class="s11">− </span>ai<span class="p">)</span><span class="s26">2</span></p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i<span class="s13">∈</span><span class="s6">vis</span></p><p style="text-indent: 0pt;line-height: 13pt;text-align: left;">2<i>σ</i><span class="s26">2</span></p><p class="s3" style="padding-left: 152pt;text-indent: 0pt;text-align: left;">	</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">j</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 8pt;padding-bottom: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;"><span class="p">(</span>hj <span class="s11">− </span>bj<span class="p">)</span><span class="s26">2</span></p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">j<span class="s13">∈</span><span class="s6">hid</span></p><p style="text-indent: 0pt;line-height: 13pt;text-align: left;">2<i>σ</i><span class="s26">2</span></p><p class="s3" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">	</p><p class="s44" style="padding-top: 9pt;padding-bottom: 4pt;padding-left: 12pt;text-indent: 0pt;text-align: left;"> <span class="s10"> </span><span class="s18">vi hj</span></p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i,j</p><p class="s9" style="text-indent: 0pt;line-height: 11pt;text-align: left;">σ</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i</p><p class="s9" style="text-indent: 0pt;line-height: 11pt;text-align: left;">σ</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">j</p><p class="s3" style="padding-left: 15pt;text-indent: 0pt;text-align: left;">  </p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 3pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">If any of the eigenvalues of the weight matrix become sufficiently large, the quadratic interaction terms can dominate the containment terms and there is then no lower bound to the energy that can be achieved by scaling up the activities in the direction of the corresponding eigenvector. With a sufficiently small learning rate, CD1 can detect and correct these directions so it is possible to learn an undirected version of a factor analysis model (Marks and Movellan, 2001) using all Gaussian units, but this is harder than using EM (Ghahramani and Hinton, 1996) to learn a directed model.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h2 style="padding-left: 42pt;text-indent: -37pt;text-align: left;">Binomial units</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">A simple way to get a unit with noisy integer values in the range 0 to <i>N </i>is to make <i>N </i>separate copies of a binary unit and give them all the same weights and bias (Teh and Hinton, 2001). Since all copies receive the same total input, they all have the same probability, <i>p</i>, of turning on and this only has to be computed once. The expected number that are on is <i>Np </i>and the variance in this number is <i>Np</i>(1 <i>p</i>). For small <i>p</i>, this acts like a Poisson unit, but as <i>p </i>approaches 1 the variance becomes small again which may not be desireable. Also, for small values of <i>p </i>the growth in <i>p </i>is exponential in the total input. This makes learning much less stable than for the rectified linear units described in section 13.5.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: left;">One nice thing about using weight-sharing to synthesize a new type of unit out of binary units is that the mathematics underlying binary-binary RBM’s remains unchanged.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h2 style="padding-left: 42pt;text-indent: -37pt;text-align: left;">Rectified linear units</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">− − − − −</p><p style="text-indent: 0pt;text-align: left;"/><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;">                                          <span class="s9">x</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">A small modification to binomial units makes them far more interesting as models of real neurons and also more useful for practical applications. All copies still have the same learned weight vector <b>w </b>and the same learned bias, <i>b</i>, but each copy has a different, fixed offset to the bias. If the offsets are 0<i>.</i>5<i>, </i>1<i>.</i>5<i>, </i>2<i>.</i>5<i>, ... </i>(<i>N </i>0<i>.</i>5) the sum of the probabilities of the copies is extremely close to having a closed form:</p><p class="s13" style="text-indent: 0pt;line-height: 6pt;text-align: center;">∞</p><p class="s9" style="padding-top: 1pt;padding-left: 186pt;text-indent: 0pt;text-align: left;">σ<span class="p">(</span>x <span class="s11">− </span>i <span class="p">+ 0</span>.<span class="p">5) </span><span class="s11">≈ </span><span class="p">log(1 + </span>e <span class="p">) (19)</span></p><p class="s12" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: center;">i<span class="s6">=1</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">where <i>x </i>= <b>vw</b><span class="s42">T </span>+ <i>b</i>. So the total activity of all of the copies behaves like a smoothed version of a rectified linear unit that saturates for sufficiently large input. Even though log(1 + <i>ex</i>) is not in the exponential family, we can model it accurately using a set of binary units with shared weights and</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">fixed bias offsets. This set has no more parameters than an ordinary binary unit, but it provides a much more expressive variable. The variance is <i>σ</i>(<i>x</i>) so units that are firmly off do not create noise and the noise does not become large when <i>x </i>is large.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">A drawback of giving each copy a bias that differs by a fixed offset is that the logistic function needs to be used many times to get the probabilities required for sampling an integer value correctly. It is possible, however, to use a fast approximation in which the sampled value of the rectified linear unit is not constrained to be an integer. Instead it is approximated by max(0<i>, x </i>+ <i>N </i>(0<i>, </i>1) where <i>N </i>(0<i>, </i>1) is Gaussian noise with zero mean and unit variance. This type of rectified linear unit seems to work fine for either visible units or hidden units when training with CD1 (Nair and Hinton, 2010).</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">If both visible and hidden units are rectified linear, a much smaller learning rate may be needed to avoid unstable dynamics in the activity or weight updates. If the weight between two rectified linear units is greater than 1 there is no lower bound to the energy that can be achieved by giving both units very high activities so there is no proper probability distribution. Nevertheless, contrastive divergence learning may still work provided the learning rate is low enough to give the learning time to detect and correct directions in which the Markov chain would blow up if allowed to run for many iterations. RBM’s composed of rectified linear units are more stable than RBM’s composed of Gaussian units because the rectification prevents biphasic oscillations of the weight dynamics in which units alternate between vary high positive activity for one mini-batch followed by very high negative activity for the next mini-batch.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li><h1 style="padding-top: 10pt;padding-left: 37pt;text-indent: -32pt;text-align: left;">Varieties of contrastive divergence</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Although CD1 is not a very good approximation to maximum likelihood learning, this does not seem to matter when an RBM is being learned in order to provide hidden features for training a higher-level RBM. CD1 ensures that the hidden features retain most of the information in the data vector and it is not necessarily a good idea to use a form of CD that is a closer approximation to maximum likelihood but is worse at retaining the information in the data vector. If, however, the aim is to learn an RBM that is a good density or joint-density model, CD1 is far from optimal.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">At the beginning of learning, the weights are small and mixing is fast so CD1 provides a good approximation to maximum likelihood. As the weights grow, the mixing gets worse and it makes sense to gradually increase the <i>n </i>in CD<i>n </i>(Carreira-Perpignan and Hinton, 2005; Salakhutdinov et al., 2007). When <i>n </i>is increased, the difference of pairwise statistics that is used for learning will increase so it may be necessary to reduce the learning rate.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">A more radical departure from CD1 is called “persistent contrastive divergence” (Tieleman, 2008). Instead of initializing each alternating Gibbs Markov chain at a datavector, which is the essence of CD learning, we keep track of the states of a number of persistent chains or “fantasy particles”. Each persisitent chain has its hidden and visible states updated one (or a few) times after each weight update. The learning signal is then the difference between the pairwise statistics measured on a mini- batch of data and the pairwise statistics measured on the persistent chains. Typically the number of persistent chains is the same as the size of a mini-batch, but there is no good reason for this. The persistent chains mix surprisingly fast because the weight-updates repel each chain from its current state by raising the energy of that state (Tieleman and Hinton, 2009).</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">When using persistent CD, the learning rate typically needs to be quite a lot smaller and the early phase of the learning is much slower in reducing the reconstruction error. In the early phase of learning the persistent chains often have very correlated states, but this goes away with time. The final reconstruction error is also typically larger than with CD1 because persistent CD is, asymptotically,</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">performing maximum likelihood learning rather than trying to make the distribution of the one-step reconstructions resemble the distribution of the data. Persistent CD learns significantly better models than CD1 or even CD10 (Tieleman, 2008) and is the recommended method if the aim is to build the best density model of the data.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">Persistent CD can be improved by adding to the standard parameters an overlay of “fast weights” which learn very rapidly but also decay very rapidly (Tieleman and Hinton, 2009). These fast weights improve the mixing of the persistent chains. However, the use of fast weights introduces yet more meta-parameters and will not be discussed further here.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-top: 10pt;padding-left: 37pt;text-indent: -32pt;text-align: left;">Displaying what is happening during learning</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">There are many ways in which learning can go wrong and most of the common problems are easy to diagnose with the right graphical displays. The three types of display described below give much more insight into what is happening than simply monitoring the reconstruction error.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">Histograms of the weights, the visible biases and the hidden biases are very useful. In addition, it is useful to examine histograms of the increments to these parameters when they are updated, though it is wasteful to make these histograms after every update.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">For domains in which the visible units have spatial or temporal structure (<i>e.g. </i>images or speech) it is very helpful to display, for each hidden unit, the weights connecting that hidden unit to the visible units. These “receptive” fields are a good way of visualizing what features the hidden units have learned. When displaying the receptive fields of many hidden units it can be very misleading to use different scales for different hidden units. Gray-scale displays of receptive fields are usually less pretty but much more informative than false colour displays.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 106%;text-align: justify;">For a single minibatch, it is very useful to see a two-dimensional, gray-scale display with a range of [0,1] that shows the probability of each binary hidden unit on each training case in a mini-batch<span class="s26">10</span>. This immediately allows you to see if some hidden units are never used or if some training cases activate an unusually large or small number of hidden units. It also shows how certain the hidden units are. When learning is working properly, this display should look thoroughly random without any obvious vertical or horizontal lines. Histograms can be used instead of this display, but it takes quite a few histograms to convey the same information.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><h1 style="padding-top: 10pt;padding-left: 37pt;text-indent: -32pt;text-align: left;">Using RBM’s for discrimination</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">There are three obvious ways of using RBMs for discrimination. The first is to use the hidden features learned by the RBM as the inputs for some standard discriminative method. This will not be discussed further here, though it is probably the most important way of using RBM’s, especially when many layers of hidden features are learned unsupervised before starting on the discriminative training.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">The second method is to train a separate RBM on each class. After training, the free energy of a test vector, <b>t</b>, is computed (see subsection 16.1)for each class-specific RBM. The log probability that the RBM trained on class <i>c </i>assigns to the test vector is given by:</p><p style="padding-top: 11pt;padding-left: 178pt;text-indent: 0pt;text-align: left;">log <i>p</i>(<b>t</b><span class="s11">|</span><i>c</i>) = <span class="s11">−</span><i>Fc</i>(<b>t</b>) <span class="s11">− </span>log <i>Zc                                                        </i>(20)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="255" height="1" alt="image" src="training-RBM-guide/Image_019.png"/></span></p><p class="s7" style="padding-left: 13pt;text-indent: 0pt;text-align: left;">10<span class="s8">If there are more than a few hundred hidden units, just use a subset of them.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">where <i>Zc </i>is the partition function of that RBM. Since each class-specific RBM will have a different, unknown partition function, the free energies cannot be used directly for discrimination. However, if the number of classes is small it is easy to deal with the unknown log partition functions by simply training a “softmax” model (on a separate training set) to predict the class from the free energies of all of the class specific RBMs:</p><p class="s6" style="padding-top: 7pt;padding-left: 136pt;text-indent: 0pt;line-height: 10pt;text-align: center;"><span class="s38">e</span><span class="s45">−</span><i>F</i><span class="s30">c</span><span class="s46">(</span><b>t</b>)<span class="s13">−</span>log <i>Z</i><span class="s36">ˆ</span><span class="s30">c</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="106" height="1" alt="image" src="training-RBM-guide/Image_020.png"/></span></p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">d</p><p style="text-indent: 0pt;text-align: left;"/><p class="s30" style="text-indent: 0pt;line-height: 6pt;text-align: left;">d</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 155pt;text-indent: 0pt;text-align: left;">log <i>p</i>(<i>class </i>= <i>c</i><span class="s11">|</span><b>t</b>) =  <span class="s47"> </span></p><p class="s6" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;"><span class="s38">e</span><span class="s13">−</span><i>F  </i>(<b>t</b>)<span class="s13">−</span>log <i>Z</i><span class="s48">ˆ</span></p><p style="text-indent: 0pt;text-align: right;">(21)</p><p class="s30" style="text-indent: 0pt;line-height: 6pt;text-align: left;">d</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">where  the  <i>Z</i><span class="s49">ˆ</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 3pt;text-indent: 0pt;text-align: left;">are parameters that are learned by maximum likleihood training of the softmax. Of</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">course, equation 21 can also be used to learn the weights and biases of each RBM but this requires a lot of data to avoid overfitting. Combining the discriminative gradients for the weights and biases that come from equation 21 with the approximate gradients that come from contrastive divergence will often do better than either method alone. The approximate gradient produced by contrastive divergence acts as a strong regularizer to prevent overfitting and the discriminative gradient ensures that there is some pressure to use the weights and biases in a way that helps discrimination.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">The third method is to train a joint density model using a single RBM that has two sets of visible units. In addition to the units that represent a data vector, there is a “softmax” label unit that represents the class. After training, each possible label is tried in turn with a test vector and the one that gives lowest free energy is chosen as the most likely class. The partition function is not a problem here, since it is the same for all classes. Again, it is possible to combine discriminiative and generative training of the joint RBM by using discriminative gradients that are the derivatives of the log probability of the correct class (Hinton, 2007):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;line-height: 2pt;text-align: right;">log (</p><p class="s50" style="padding-top: 3pt;padding-left: 25pt;text-indent: 0pt;line-height: 13%;text-align: left;">= <b>t</b><span class="p">) = </span><i>e</i><span class="s45">−</span><span class="s12">F</span><span class="s30">c</span><span class="s46">(</span><span class="s15">t</span><span class="s6">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 69pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="67" height="1" alt="image" src="training-RBM-guide/Image_021.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;line-height: 2pt;text-align: right;">(22)</p><p class="s9" style="text-indent: 0pt;line-height: 5pt;text-align: right;">p  class     c<span class="s11">|</span></p><p class="s6" style="padding-left: 22pt;text-indent: 0pt;line-height: 65%;text-align: left;"><span class="s51"> </span><i>d </i><span class="s38">e</span><span class="s13">−</span><i>F</i><span class="s37">d</span>(<b>t</b>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l26"><li><h2 style="padding-top: 9pt;padding-left: 42pt;text-indent: -37pt;text-align: left;">Computing the free energy of a visible vector</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">The free energy of visible vector <b>v </b>is the energy that a single configuration would need to have in order to have the same probability as all of the configurations that contain <b>v</b>:</p><p class="s6" style="padding-top: 9pt;padding-left: 193pt;text-indent: 0pt;text-align: left;"><span class="s14">e</span><span class="s13">−</span><i>F </i>(<b>v</b>) <span class="s16">=</span><span class="p"> </span><span class="s9">e</span><span class="s13">−</span><i>E</i>(<b>v</b><i>,</i><b>h</b>) <span class="s16">(23)</span></p><p class="s15" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: center;">h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">It is also given by the expected energy minus the entropy:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="text-indent: 0pt;line-height: 11pt;text-align: left;"> </p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-bottom: 4pt;padding-left: 83pt;text-indent: 0pt;text-align: center;"><i>F </i>(<b>v</b>) = <span class="s11">− </span><span class="s53">  </span><i>viai </i><span class="s11">− </span><span class="s53">  </span><i>pjxj </i>+ <span class="s54">   </span> (<i>pj </i>log <i>pj </i>+ (1 <span class="s11">− </span><i>pj</i>) log(1 <span class="s11">− </span><i>pj</i>))         (24)</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">j</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">j</p><p style="padding-left: 141pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span style=" color: black; font-family:&quot;Times New Roman&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt;">		</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 14pt;text-align: left;">where <i>xj </i>= <i>bj </i>+ <span class="s23">i </span><i>viwij </i>is the total input to hidden unit <i>j </i>and <i>pj </i>= <i>σ</i>(<i>xj</i>) is the probability that</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><i>hj </i>= 1 given <b>v</b>. A good way to compute F(<b>v</b>) is to use yet another expression for the free energy:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-bottom: 4pt;padding-left: 158pt;text-indent: 0pt;text-align: left;"><i>F </i>(<b>v</b>) = <span class="s11">− </span><span class="s40"> </span><span class="s10"> </span><i>viai </i><span class="s11">− </span><span class="s40"> </span><span class="s10"> </span>log(1 + <i>ex</i><span class="s55">j</span><span class="s30"> </span>)                                                 (25)</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">j</p><p style="padding-left: 213pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span style=" color: black; font-family:&quot;Times New Roman&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt;">	</span></p></li></ol></li><li><h1 style="padding-top: 22pt;padding-left: 37pt;text-indent: -32pt;text-align: left;">Dealing with missing values</h1></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">In a directed belief net it is very easy to deal with missing values for visible variables. When performing inference, a missing value that is at the receiving end of a directed connection has no effect on the</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">units that send connections to it. This is not true for the undirected connections used in an RBM. To perform inference in the standard way, the missing value must first be filled in and there are at least two ways to do this.</p><p class="s11" style="text-indent: 0pt;line-height: 11pt;text-align: left;">−</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">A particularly simple type of missing value occurs when learning a joint density for data in which each training case is composed of a vector <b>v </b>such as an image plus a single discrete label. If the label is missing from a subset of the cases, it can be Gibbs sampled from its exact conditional distribution. This is done by computing the free energy (see section 16.1) for each possible value of the label and then picking label <i>l </i>with probability proportional to exp( <i>F </i>(<i>l, </i><b>v</b>). After this, the training case is treated just like a complete training case.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">For real-valued visible units, there is a different way to impute missing values that still works well even if several values are missing from the same training case (Hinton et al., 2006b). If the learning cycles through the training set many times, the missing values can be treated in just the same way as the other parameters. Starting with a sensible initial guess, a missing value is updated each time the weights are updated, but possibly using a different learning rate. The update for the missing value for visible unit <i>i </i>on training case <i>c </i>is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i</p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="text-indent: 0pt;line-height: 13pt;text-align: left;">∂v<span class="p">ˆ</span><span class="s42">c</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="text-indent: 0pt;line-height: 12pt;text-align: left;">∂v<span class="s42">c</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 3pt;padding-bottom: 2pt;padding-left: 190pt;text-indent: 0pt;text-align: left;"><span class="p">∆</span>vc <span class="p">= </span>E <span class="s56">( </span><u>∂F</u> <span class="s11">− </span><u>∂F</u><span class="s57"> </span><span class="p">(26)</span></p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i</p><p class="s12" style="text-indent: 0pt;line-height: 8pt;text-align: left;">i</p><p style="padding-left: 251pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span style=" color: black; font-family:&quot;Times New Roman&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt;">	</span></p><p style="padding-top: 8pt;padding-left: 22pt;text-indent: 0pt;line-height: 9pt;text-align: left;">where <i>vc </i>is the imputed value and <i>v</i>ˆ<span class="s42">c</span><span class="s12">  </span>is the reconstruction of the imputed value.  Momentum can</p><p class="s12" style="padding-left: 58pt;text-indent: 0pt;line-height: 6pt;text-align: left;">i i</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">be used for imputed values in just the same way as it is used for the usual parameters.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">There is a more radical way of dealing with missing values that can be used when the number of missing values is very large. This occurs, for example, with user preference data where most users do not express their preference for most objects (Salakhutdinov et al., 2007). Instead of trying to impute the missing values, we pretend they do not exist by using RBM’s with different numbers of visible units for different training cases. The different RBMs form a family of different models with shared weights. Each RBM in the family can now do correct inference for its hidden states, but the tying of the weights means that they may not be ideal for any particular RBM. Adding a visible unit for a missing value and then performing correct inference that integrates out this missing value does not give the same distribution for the hidden units as simply ommitting the visible unit which is why this is a family of models rather than just one model. When using a family of models to deal with missing values, it can be very helpful to scale the hidden biases by the number of visible units in the RBM (Salakhutdinov and Hinton, 2009).</p><h3 style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Acknowledgements</h3><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 16pt;line-height: 107%;text-align: justify;">This research was supported by NSERC and the Canadian Institute for Advanced Research. Many of my past and present graduate students and postdocs have made valuable contributions to the body of practical knowledge described in this technical report. I have tried to acknowledge particularly valuable contributions in the report, but I cannot always recall who suggested what.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 10pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">References</h1><p style="padding-top: 11pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Carreira-Perpignan, M. A. and Hinton, G. E. (2005). On contrastive divergence learning. In <i>Artificial Intelligence and Statistics, 2005</i>.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Freund, Y. and Haussler, D. (1992). Unsupervised learning of distributions on binary vectors using two layer networks. In <i>Advances in Neural Information Processing Systems 4</i>, pages 912–919, San Mateo, CA. Morgan Kaufmann.</p><p style="padding-top: 4pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Ghahramani, Z. and Hinton, G. (1996). The EM algorithm for mixtures of factor analyzers. Technical Report CRG-TR-96-1, University of Toronto.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Hinton, G. E. (1978). Relaxation and its role in vision. In <i>PhD Thesis</i>.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Hinton, G. E. (2002). Training products of experts by minimizing contrastive divergence. <i>Neural Computation</i>, 14(8):1711–1800.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Hinton, G. E. (2007). To recognize shapes, first learn to generate images. <i>Computational Neuroscience: Theoretical Insights into Brain Function.</i></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Hinton, G. E., Osindero, S., and Teh, Y. W. (2006a). A fast learning algorithm for deep belief nets.</p><p class="s9" style="padding-left: 15pt;text-indent: 0pt;text-align: left;">Neural Computation<span class="p">, 18(7):1527–1554.</span></p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Hinton, G. E., Osindero, S., Welling, M., and Teh, Y. (2006b). Unsupervised discovery of non-linear structure using contrastive backpropagation. <i>Cognitive Science</i>, 30:725–731.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Hopfield, J. J. (1982). Neural networks and physical systems with emergent collective computational abilities. <i>Proceedings of the National Academy of Sciences</i>, 79:2554–2558.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Marks, T. K. and Movellan, J. R. (2001). Diffusion networks, product of experts, and factor analysis.</p><p style="padding-left: 15pt;text-indent: 0pt;text-align: left;">In <i>Proc. Int. Conf. on Independent Component Analysis</i>, pages 481–485.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Mohamed, A. R., Dahl, G., and Hinton, G. E. (2009). Deep belief networks for phone recognition.</p><p style="padding-left: 15pt;text-indent: 0pt;text-align: left;">In <i>NIPS 22 workshop on deep learning for speech recognition</i>.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Mohamed, A. R. and Hinton, G. E. (2010). Phone recognition using restricted boltzmann machines.</p><p style="padding-left: 15pt;text-indent: 0pt;text-align: left;">In <i>ICASSP-2010</i>.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Nair, V. and Hinton, G. E. (2009). 3-d object recognition with deep belief nets. In <i>Advances in Neural Information Processing Systems</i>, volume 22, pages 1339–1347.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Nair, V. and Hinton, G. E. (2010). Rectified linear units improve restricted boltzmann machines. In</p><p class="s9" style="padding-left: 15pt;text-indent: 0pt;text-align: left;">Proc. 27th International Conference on Machine Learning<span class="p">.</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Salakhutdinov, R. R. and Hinton, G. E. (2009). Replicated softmax: An undirected topic model. In</p><p class="s9" style="padding-left: 15pt;text-indent: 0pt;text-align: left;">Advances in Neural Information Processing Systems<span class="p">, volume 22.</span></p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Salakhutdinov, R. R., Mnih, A., and Hinton, G. E. (2007). Restricted Boltzmann machines for collaborative filtering. In Ghahramani, Z., editor, <i>Proceedings of the International Conference on Machine Learning</i>, volume 24, pages 791–798. ACM.</p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Salakhutdinov, R. R. and Murray, I. (2008).  On the quantitative analysis of deep belief networks.  In</p><p class="s9" style="padding-left: 3pt;text-indent: 0pt;text-align: center;">Proceedings of the International Conference on Machine Learning<span class="p">, volume 25, pages 872 – 879.</span></p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Smolensky, P. (1986). Information processing in dynamical systems: Foundations of harmony theory. In Rumelhart, D. E. and McClelland, J. L., editors, <i>Parallel Distributed Processing</i>, volume 1, chapter 6, pages 194–281. MIT Press, Cambridge.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Sutskever, I. and Tieleman (2010). On the convergence properties of contrastive divergence. In <i>Pro- ceedings of the 13th International Conference on Artificial Intelligence and Statistics (AISTATS)</i>, Sardinia, Italy.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Taylor, G., Hinton, G. E., and Roweis, S. T. (2006). Modeling human motion using binary latent variables. In <i>Advances in Neural Information Processing Systems</i>. MIT Press.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Teh, Y. and Hinton, G. E. (2001). Rate-coded restricted Boltzmann machines for face recognition.</p><p style="padding-left: 15pt;text-indent: 0pt;text-align: left;">In <i>Advances in Neural Information Processing Systems</i>, volume 13, pages 908–914.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Tieleman, T. (2008). Training restricted Boltzmann machines using approximations to the likelihood gradient. In <i>Machine Learning, Proceedings of the Twenty-first International Conference (ICML 2008)</i>. ACM.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Tieleman, T. and Hinton, G. (2009). Using fast weights to improve persistent contrastive divergence. In <i>Proceedings of the 26th international conference on Machine learning</i>, pages 1033–1040. ACM New York, NY, USA.</p><p style="padding-top: 9pt;padding-left: 15pt;text-indent: -10pt;line-height: 107%;text-align: justify;">Welling, M., Rosen-Zvi, M., and Hinton, G. E. (2005). Exponential family harmoniums with an application to information retrieval. In <i>Advances in Neural Information Processing Systems</i>, pages 1481–1488, Cambridge, MA. MIT Press.</p></body></html>
